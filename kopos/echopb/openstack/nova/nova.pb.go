// Code generated by protoc-gen-gogo.
// source: openstack/nova/nova.proto
// DO NOT EDIT!

/*
	Package nova is a generated protocol buffer package.

	It is generated from these files:
		openstack/nova/nova.proto

	It has these top-level messages:
		Flavor
		Image
		Server
		Network
		File
		Addresses
		Address
		SecurityGroups
		SecurityGroup
		Rule
		IPRange
		Group
*/
package nova

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Flavor records represent (virtual) hardware configurations for server resources in a region.
type Flavor struct {
	// The Id field contains the flavor's unique identifier.
	// For example, this identifier will be useful when specifying which hardware configuration to use for a new server instance.
	// ID string json:"id"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The Disk and RA< fields provide a measure of storage space offered by the flavor, in GB and MB, respectively.
	// Disk int json:"disk"
	// RAM  int json:"ram"
	Disk int32 `protobuf:"varint,2,opt,name=disk,proto3" json:"disk,omitempty"`
	Ram  int32 `protobuf:"varint,3,opt,name=ram,proto3" json:"ram,omitempty"`
	// The Name field provides a human-readable moniker for the flavor.
	// Name       string  json:"name"
	// RxTxFactor float64 json:"rxtx_factor"
	Name       string  `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	RxtxFactor float64 `protobuf:"fixed64,5,opt,name=rxtx_factor,json=rxtxFactor,proto3" json:"rxtx_factor,omitempty"`
	// Swap indicates how much space is reserved for swap.
	// If not provided, this field will be set to 0.
	// Swap int json:"swap"
	Swap int32 `protobuf:"varint,6,opt,name=swap,proto3" json:"swap,omitempty"`
	// VCPUs indicates how many (virtual) CPUs are available for this flavor.
	// VCPUs int json:"vcpus"
	Vcpus int32 `protobuf:"varint,7,opt,name=vcpus,proto3" json:"vcpus,omitempty"`
	// IsPublic indicates whether the flavor is public.
	// IsPublic bool json:"is_public"
	IsPublic bool `protobuf:"varint,8,opt,name=is_public,json=isPublic,proto3" json:"is_public,omitempty"`
}

func (m *Flavor) Reset()                    { *m = Flavor{} }
func (m *Flavor) String() string            { return proto.CompactTextString(m) }
func (*Flavor) ProtoMessage()               {}
func (*Flavor) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{0} }

func (m *Flavor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Flavor) GetDisk() int32 {
	if m != nil {
		return m.Disk
	}
	return 0
}

func (m *Flavor) GetRam() int32 {
	if m != nil {
		return m.Ram
	}
	return 0
}

func (m *Flavor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Flavor) GetRxtxFactor() float64 {
	if m != nil {
		return m.RxtxFactor
	}
	return 0
}

func (m *Flavor) GetSwap() int32 {
	if m != nil {
		return m.Swap
	}
	return 0
}

func (m *Flavor) GetVcpus() int32 {
	if m != nil {
		return m.Vcpus
	}
	return 0
}

func (m *Flavor) GetIsPublic() bool {
	if m != nil {
		return m.IsPublic
	}
	return false
}

// Image is used for JSON (un)marshalling.
// It provides a description of an OS image.
type Image struct {
	// ID contains the image's unique identifier.
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Created string `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	// MinDisk and MinRAM specify the minimum resources a server must provide to be able to install the image.
	MinDisk int32 `protobuf:"varint,3,opt,name=min_disk,json=minDisk,proto3" json:"min_disk,omitempty"`
	MinRam  int32 `protobuf:"varint,4,opt,name=min_ram,json=minRam,proto3" json:"min_ram,omitempty"`
	// Name provides a human-readable moniker for the OS image.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The Progress and Status fields indicate image-creation status.
	// Any usable image will have 100% progress.
	Progress int32             `protobuf:"varint,6,opt,name=progress,proto3" json:"progress,omitempty"`
	Status   string            `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	Updated  string            `protobuf:"bytes,8,opt,name=updated,proto3" json:"updated,omitempty"`
	Metadata map[string]string `protobuf:"bytes,9,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{1} }

func (m *Image) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Image) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *Image) GetMinDisk() int32 {
	if m != nil {
		return m.MinDisk
	}
	return 0
}

func (m *Image) GetMinRam() int32 {
	if m != nil {
		return m.MinRam
	}
	return 0
}

func (m *Image) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Image) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *Image) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Image) GetUpdated() string {
	if m != nil {
		return m.Updated
	}
	return ""
}

func (m *Image) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Server exposes only the standard OpenStack fields corresponding to a given server on the user's account.
type Server struct {
	// ID uniquely identifies this server amongst all other servers, including those not accessible to the current tenant.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// TenantID identifies the tenant owning this server resource.
	TenantId string `protobuf:"bytes,2,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// UserID uniquely identifies the user account owning the tenant.
	UserId string `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Name contains the human-readable name for the server.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// Updated and Created contain ISO-8601 timestamps of when the state of the server last changed, and when it was created.
	// google.protobuf.Timestamp updated = 5;
	Updated string `protobuf:"bytes,5,opt,name=updated,proto3" json:"updated,omitempty"`
	// google.protobuf.Timestamp created = 6;
	Created string `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
	HostId  string `protobuf:"bytes,7,opt,name=host_id,json=hostId,proto3" json:"host_id,omitempty"`
	// Status contains the current operational status of the server, such as IN_PROGRESS or ACTIVE.
	Status string `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	// Progress ranges from 0..100.
	// A request made against the server completes only once Progress reaches 100.
	Progress int32 `protobuf:"varint,9,opt,name=progress,proto3" json:"progress,omitempty"`
	// AccessIPv4 and AccessIPv6 contain the IP addresses of the server, suitable for remote access for administration.
	AccessIPv4 string `protobuf:"bytes,10,opt,name=accessIPv4,proto3" json:"accessIPv4,omitempty"`
	AccessIPv6 string `protobuf:"bytes,11,opt,name=accessIPv6,proto3" json:"accessIPv6,omitempty"`
	// Image refers to a JSON object, which itself indicates the OS image used to deploy the server.
	Images map[string]*Image `protobuf:"bytes,12,rep,name=images" json:"images,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Flavor refers to a JSON object, which itself indicates the hardware configuration of the deployed server.
	Flavors map[string]*Flavor `protobuf:"bytes,13,rep,name=flavors" json:"flavors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Addresses includes a list of all IP addresses assigned to the server, keyed by pool.
	Addresses map[string]*Addresses `protobuf:"bytes,14,rep,name=addresses" json:"addresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Metadata includes a list of all user-specified key-value pairs attached to the server.
	MetadataInfo map[string]string `protobuf:"bytes,15,rep,name=metadata_info,json=metadataInfo" json:"metadata_info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Links includes HTTP references to the itself, useful for passing along to other APIs that might want a server reference.
	Links []string `protobuf:"bytes,16,rep,name=links" json:"links,omitempty"`
	// KeyName indicates which public key was injected into the server on launch.
	KeyName string `protobuf:"bytes,17,opt,name=key_name,json=keyName,proto3" json:"key_name,omitempty"`
	// AdminPass will generally be empty ("").  However, it will contain the administrative password chosen when provisioning a new server without a set AdminPass setting in the first place.
	// Note that this is the ONLY time this field will be valid.
	AdminPass string `protobuf:"bytes,18,opt,name=adminPass,proto3" json:"adminPass,omitempty"`
	// SecurityGroups includes the security groups that this instance has applied to it
	SecurityGroups []*SecurityGroups `protobuf:"bytes,20,rep,name=security_groups,json=securityGroups" json:"security_groups,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{2} }

func (m *Server) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Server) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Server) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Server) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Server) GetUpdated() string {
	if m != nil {
		return m.Updated
	}
	return ""
}

func (m *Server) GetCreated() string {
	if m != nil {
		return m.Created
	}
	return ""
}

func (m *Server) GetHostId() string {
	if m != nil {
		return m.HostId
	}
	return ""
}

func (m *Server) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Server) GetProgress() int32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

func (m *Server) GetAccessIPv4() string {
	if m != nil {
		return m.AccessIPv4
	}
	return ""
}

func (m *Server) GetAccessIPv6() string {
	if m != nil {
		return m.AccessIPv6
	}
	return ""
}

func (m *Server) GetImages() map[string]*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *Server) GetFlavors() map[string]*Flavor {
	if m != nil {
		return m.Flavors
	}
	return nil
}

func (m *Server) GetAddresses() map[string]*Addresses {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Server) GetMetadataInfo() map[string]string {
	if m != nil {
		return m.MetadataInfo
	}
	return nil
}

func (m *Server) GetLinks() []string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *Server) GetKeyName() string {
	if m != nil {
		return m.KeyName
	}
	return ""
}

func (m *Server) GetAdminPass() string {
	if m != nil {
		return m.AdminPass
	}
	return ""
}

func (m *Server) GetSecurityGroups() []*SecurityGroups {
	if m != nil {
		return m.SecurityGroups
	}
	return nil
}

// Network is used within CreateOpts to control a new server's network attachments.
type Network struct {
	// UUID of a nova-network to attach to the newly provisioned server.
	// Required unless Port is provided.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Port of a neutron network to attach to the newly provisioned server.
	// Required unless UUID is provided.
	Port string `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	// FixedIP [optional] specifies a fixed IPv4 address to be used on this network.
	FixedIp string `protobuf:"bytes,3,opt,name=fixed_ip,json=fixedIp,proto3" json:"fixed_ip,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{3} }

func (m *Network) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Network) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *Network) GetFixedIp() string {
	if m != nil {
		return m.FixedIp
	}
	return ""
}

// File is used within CreateOpts and RebuildOpts to inject a file into the server at launch.
// File implements the json.Marshaler interface, so when a Create or Rebuild operation is requested,
// json.Marshal will call File's MarshalJSON method.
type File struct {
	// Path of the file
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Contents of the file. Maximum content size is 255 bytes.
	Contents []byte `protobuf:"bytes,2,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{4} }

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *File) GetContents() []byte {
	if m != nil {
		return m.Contents
	}
	return nil
}

type Addresses struct {
	Addresses []*Address `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
}

func (m *Addresses) Reset()                    { *m = Addresses{} }
func (m *Addresses) String() string            { return proto.CompactTextString(m) }
func (*Addresses) ProtoMessage()               {}
func (*Addresses) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{5} }

func (m *Addresses) GetAddresses() []*Address {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// Address represents an IP address.
type Address struct {
	Version      int32             `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Addr         string            `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	MacAddr      string            `protobuf:"bytes,3,opt,name=mac_addr,json=macAddr,proto3" json:"mac_addr,omitempty"`
	AssignedType string            `protobuf:"bytes,4,opt,name=assigned_type,json=assignedType,proto3" json:"assigned_type,omitempty"`
	Ext          map[string][]byte `protobuf:"bytes,5,rep,name=ext" json:"ext,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{6} }

func (m *Address) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Address) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Address) GetMacAddr() string {
	if m != nil {
		return m.MacAddr
	}
	return ""
}

func (m *Address) GetAssignedType() string {
	if m != nil {
		return m.AssignedType
	}
	return ""
}

func (m *Address) GetExt() map[string][]byte {
	if m != nil {
		return m.Ext
	}
	return nil
}

type SecurityGroups struct {
	SecurityGroups map[string]*SecurityGroup `protobuf:"bytes,1,rep,name=security_groups,json=securityGroups" json:"security_groups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *SecurityGroups) Reset()                    { *m = SecurityGroups{} }
func (m *SecurityGroups) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroups) ProtoMessage()               {}
func (*SecurityGroups) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{7} }

func (m *SecurityGroups) GetSecurityGroups() map[string]*SecurityGroup {
	if m != nil {
		return m.SecurityGroups
	}
	return nil
}

// SecurityGroup represents a security group.
type SecurityGroup struct {
	// The unique ID of the group. If Neutron is installed, this ID will be
	// represented as a string UUID; if Neutron is not installed, it will be a
	// numeric ID. For the sake of consistency, we always cast it to a string.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The human-readable name of the group, which needs to be unique.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The human-readable description of the group.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The rules which determine how this security group operates.
	Rules []*Rule `protobuf:"bytes,4,rep,name=rules" json:"rules,omitempty"`
	// The ID of the tenant to which this security group belongs.
	TenantId string `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *SecurityGroup) Reset()                    { *m = SecurityGroup{} }
func (m *SecurityGroup) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroup) ProtoMessage()               {}
func (*SecurityGroup) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{8} }

func (m *SecurityGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SecurityGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecurityGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SecurityGroup) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *SecurityGroup) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

// Rule represents a security group rule, a policy which determines how a
// security group operates and what inbound traffic it allows in.
type Rule struct {
	// The unique ID. If Neutron is installed, this ID will be
	// represented as a string UUID; if Neutron is not installed, it will be a
	// numeric ID. For the sake of consistency, we always cast it to a string.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The lower bound of the port range which this security group should open up
	FromPort int32 `protobuf:"varint,2,opt,name=from_port,json=fromPort,proto3" json:"from_port,omitempty"`
	// The upper bound of the port range which this security group should open up
	ToPort int32 `protobuf:"varint,3,opt,name=to_port,json=toPort,proto3" json:"to_port,omitempty"`
	// The IP protocol (e.g. TCP) which the security group accepts
	IpProtocol string `protobuf:"bytes,4,opt,name=ip_protocol,json=ipProtocol,proto3" json:"ip_protocol,omitempty"`
	// The CIDR IP range whose traffic can be received
	IpRange *IPRange `protobuf:"bytes,5,opt,name=ip_range,json=ipRange" json:"ip_range,omitempty"`
	// The security group ID to which this rule belongs
	ParentGroupId string `protobuf:"bytes,6,opt,name=parent_group_id,json=parentGroupId,proto3" json:"parent_group_id,omitempty"`
	// Not documented.
	Group *Group `protobuf:"bytes,7,opt,name=group" json:"group,omitempty"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{9} }

func (m *Rule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Rule) GetFromPort() int32 {
	if m != nil {
		return m.FromPort
	}
	return 0
}

func (m *Rule) GetToPort() int32 {
	if m != nil {
		return m.ToPort
	}
	return 0
}

func (m *Rule) GetIpProtocol() string {
	if m != nil {
		return m.IpProtocol
	}
	return ""
}

func (m *Rule) GetIpRange() *IPRange {
	if m != nil {
		return m.IpRange
	}
	return nil
}

func (m *Rule) GetParentGroupId() string {
	if m != nil {
		return m.ParentGroupId
	}
	return ""
}

func (m *Rule) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

// IPRange represents the IP range whose traffic will be accepted by the
// security group.
type IPRange struct {
	Cidr string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
}

func (m *IPRange) Reset()                    { *m = IPRange{} }
func (m *IPRange) String() string            { return proto.CompactTextString(m) }
func (*IPRange) ProtoMessage()               {}
func (*IPRange) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{10} }

func (m *IPRange) GetCidr() string {
	if m != nil {
		return m.Cidr
	}
	return ""
}

// Group represents a group.
type Group struct {
	TenantId string `protobuf:"bytes,1,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptorNova, []int{11} }

func (m *Group) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*Flavor)(nil), "echopb.openstack.nova.Flavor")
	proto.RegisterType((*Image)(nil), "echopb.openstack.nova.Image")
	proto.RegisterType((*Server)(nil), "echopb.openstack.nova.Server")
	proto.RegisterType((*Network)(nil), "echopb.openstack.nova.Network")
	proto.RegisterType((*File)(nil), "echopb.openstack.nova.File")
	proto.RegisterType((*Addresses)(nil), "echopb.openstack.nova.Addresses")
	proto.RegisterType((*Address)(nil), "echopb.openstack.nova.Address")
	proto.RegisterType((*SecurityGroups)(nil), "echopb.openstack.nova.SecurityGroups")
	proto.RegisterType((*SecurityGroup)(nil), "echopb.openstack.nova.SecurityGroup")
	proto.RegisterType((*Rule)(nil), "echopb.openstack.nova.Rule")
	proto.RegisterType((*IPRange)(nil), "echopb.openstack.nova.IPRange")
	proto.RegisterType((*Group)(nil), "echopb.openstack.nova.Group")
}
func (m *Flavor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flavor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Disk != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Disk))
	}
	if m.Ram != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Ram))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RxtxFactor != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Nova(dAtA, i, uint64(math.Float64bits(float64(m.RxtxFactor))))
	}
	if m.Swap != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Swap))
	}
	if m.Vcpus != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Vcpus))
	}
	if m.IsPublic {
		dAtA[i] = 0x40
		i++
		if m.IsPublic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if m.MinDisk != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.MinDisk))
	}
	if m.MinRam != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.MinRam))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Progress != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Progress))
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Updated) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Updated)))
		i += copy(dAtA[i:], m.Updated)
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x4a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + 1 + len(v) + sovNova(uint64(len(v)))
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Server) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if len(m.UserId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Updated) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Updated)))
		i += copy(dAtA[i:], m.Updated)
	}
	if len(m.Created) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Created)))
		i += copy(dAtA[i:], m.Created)
	}
	if len(m.HostId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.HostId)))
		i += copy(dAtA[i:], m.HostId)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.Progress != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Progress))
	}
	if len(m.AccessIPv4) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.AccessIPv4)))
		i += copy(dAtA[i:], m.AccessIPv4)
	}
	if len(m.AccessIPv6) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.AccessIPv6)))
		i += copy(dAtA[i:], m.AccessIPv6)
	}
	if len(m.Images) > 0 {
		for k, _ := range m.Images {
			dAtA[i] = 0x62
			i++
			v := m.Images[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNova(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + msgSize
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNova(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.Flavors) > 0 {
		for k, _ := range m.Flavors {
			dAtA[i] = 0x6a
			i++
			v := m.Flavors[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNova(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + msgSize
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNova(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if len(m.Addresses) > 0 {
		for k, _ := range m.Addresses {
			dAtA[i] = 0x72
			i++
			v := m.Addresses[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNova(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + msgSize
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNova(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.MetadataInfo) > 0 {
		for k, _ := range m.MetadataInfo {
			dAtA[i] = 0x7a
			i++
			v := m.MetadataInfo[k]
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + 1 + len(v) + sovNova(uint64(len(v)))
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.KeyName) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.KeyName)))
		i += copy(dAtA[i:], m.KeyName)
	}
	if len(m.AdminPass) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.AdminPass)))
		i += copy(dAtA[i:], m.AdminPass)
	}
	if len(m.SecurityGroups) > 0 {
		for _, msg := range m.SecurityGroups {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintNova(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.FixedIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.FixedIp)))
		i += copy(dAtA[i:], m.FixedIp)
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Contents) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Contents)))
		i += copy(dAtA[i:], m.Contents)
	}
	return i, nil
}

func (m *Addresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addresses) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, msg := range m.Addresses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Version))
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if len(m.MacAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.MacAddr)))
		i += copy(dAtA[i:], m.MacAddr)
	}
	if len(m.AssignedType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.AssignedType)))
		i += copy(dAtA[i:], m.AssignedType)
	}
	if len(m.Ext) > 0 {
		for k, _ := range m.Ext {
			dAtA[i] = 0x2a
			i++
			v := m.Ext[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovNova(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + byteSize
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNova(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *SecurityGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecurityGroups) > 0 {
		for k, _ := range m.SecurityGroups {
			dAtA[i] = 0xa
			i++
			v := m.SecurityGroups[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovNova(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovNova(uint64(len(k))) + msgSize
			i = encodeVarintNova(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNova(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNova(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *SecurityGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNova(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	return i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.FromPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.FromPort))
	}
	if m.ToPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.ToPort))
	}
	if len(m.IpProtocol) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.IpProtocol)))
		i += copy(dAtA[i:], m.IpProtocol)
	}
	if m.IpRange != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.IpRange.Size()))
		n5, err := m.IpRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.ParentGroupId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.ParentGroupId)))
		i += copy(dAtA[i:], m.ParentGroupId)
	}
	if m.Group != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNova(dAtA, i, uint64(m.Group.Size()))
		n6, err := m.Group.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *IPRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cidr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Cidr)))
		i += copy(dAtA[i:], m.Cidr)
	}
	return i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TenantId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNova(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func encodeFixed64Nova(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Nova(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNova(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Flavor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.Disk != 0 {
		n += 1 + sovNova(uint64(m.Disk))
	}
	if m.Ram != 0 {
		n += 1 + sovNova(uint64(m.Ram))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.RxtxFactor != 0 {
		n += 9
	}
	if m.Swap != 0 {
		n += 1 + sovNova(uint64(m.Swap))
	}
	if m.Vcpus != 0 {
		n += 1 + sovNova(uint64(m.Vcpus))
	}
	if m.IsPublic {
		n += 2
	}
	return n
}

func (m *Image) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.MinDisk != 0 {
		n += 1 + sovNova(uint64(m.MinDisk))
	}
	if m.MinRam != 0 {
		n += 1 + sovNova(uint64(m.MinRam))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.Progress != 0 {
		n += 1 + sovNova(uint64(m.Progress))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Updated)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + 1 + len(v) + sovNova(uint64(len(v)))
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Server) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Updated)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Created)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.HostId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.Progress != 0 {
		n += 1 + sovNova(uint64(m.Progress))
	}
	l = len(m.AccessIPv4)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.AccessIPv6)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if len(m.Images) > 0 {
		for k, v := range m.Images {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNova(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	if len(m.Flavors) > 0 {
		for k, v := range m.Flavors {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNova(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	if len(m.Addresses) > 0 {
		for k, v := range m.Addresses {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNova(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	if len(m.MetadataInfo) > 0 {
		for k, v := range m.MetadataInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + 1 + len(v) + sovNova(uint64(len(v)))
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	if len(m.Links) > 0 {
		for _, s := range m.Links {
			l = len(s)
			n += 2 + l + sovNova(uint64(l))
		}
	}
	l = len(m.KeyName)
	if l > 0 {
		n += 2 + l + sovNova(uint64(l))
	}
	l = len(m.AdminPass)
	if l > 0 {
		n += 2 + l + sovNova(uint64(l))
	}
	if len(m.SecurityGroups) > 0 {
		for _, e := range m.SecurityGroups {
			l = e.Size()
			n += 2 + l + sovNova(uint64(l))
		}
	}
	return n
}

func (m *Network) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.FixedIp)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func (m *Addresses) Size() (n int) {
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 1 + l + sovNova(uint64(l))
		}
	}
	return n
}

func (m *Address) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovNova(uint64(m.Version))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.MacAddr)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.AssignedType)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if len(m.Ext) > 0 {
		for k, v := range m.Ext {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovNova(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecurityGroups) Size() (n int) {
	var l int
	_ = l
	if len(m.SecurityGroups) > 0 {
		for k, v := range m.SecurityGroups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNova(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovNova(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNova(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecurityGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovNova(uint64(l))
		}
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func (m *Rule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.FromPort != 0 {
		n += 1 + sovNova(uint64(m.FromPort))
	}
	if m.ToPort != 0 {
		n += 1 + sovNova(uint64(m.ToPort))
	}
	l = len(m.IpProtocol)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.IpRange != nil {
		l = m.IpRange.Size()
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.ParentGroupId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func (m *IPRange) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cidr)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func (m *Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNova(uint64(l))
	}
	return n
}

func sovNova(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNova(x uint64) (n int) {
	return sovNova(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Flavor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flavor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flavor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			m.Disk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Disk |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ram", wireType)
			}
			m.Ram = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ram |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxtxFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.RxtxFactor = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Swap |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vcpus", wireType)
			}
			m.Vcpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vcpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDisk", wireType)
			}
			m.MinDisk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDisk |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRam", wireType)
			}
			m.MinRam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRam |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthNova
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Metadata[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Metadata[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updated = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Created = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			m.Progress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Progress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessIPv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessIPv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessIPv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessIPv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Images == nil {
				m.Images = make(map[string]*Image)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Image{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Images[mapkey] = mapvalue
			} else {
				var mapvalue *Image
				m.Images[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flavors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Flavors == nil {
				m.Flavors = make(map[string]*Flavor)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Flavor{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Flavors[mapkey] = mapvalue
			} else {
				var mapvalue *Flavor
				m.Flavors[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Addresses == nil {
				m.Addresses = make(map[string]*Addresses)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Addresses{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Addresses[mapkey] = mapvalue
			} else {
				var mapvalue *Addresses
				m.Addresses[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.MetadataInfo == nil {
				m.MetadataInfo = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthNova
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.MetadataInfo[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.MetadataInfo[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Links", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Links = append(m.Links, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminPass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroups = append(m.SecurityGroups, &SecurityGroups{})
			if err := m.SecurityGroups[len(m.SecurityGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], dAtA[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, &Address{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Ext == nil {
				m.Ext = make(map[string][]byte)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapbyteLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapbyteLen |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intMapbyteLen := int(mapbyteLen)
				if intMapbyteLen < 0 {
					return ErrInvalidLengthNova
				}
				postbytesIndex := iNdEx + intMapbyteLen
				if postbytesIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := make([]byte, mapbyteLen)
				copy(mapvalue, dAtA[iNdEx:postbytesIndex])
				iNdEx = postbytesIndex
				m.Ext[mapkey] = mapvalue
			} else {
				var mapvalue []byte
				m.Ext[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNova
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.SecurityGroups == nil {
				m.SecurityGroups = make(map[string]*SecurityGroup)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNova
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthNova
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &SecurityGroup{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.SecurityGroups[mapkey] = mapvalue
			} else {
				var mapvalue *SecurityGroup
				m.SecurityGroups[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPort", wireType)
			}
			m.FromPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToPort", wireType)
			}
			m.ToPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpRange == nil {
				m.IpRange = &IPRange{}
			}
			if err := m.IpRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNova
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNova
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNova
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNova(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNova
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNova(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNova
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNova
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNova
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNova
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNova
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNova(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNova = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNova   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("openstack/nova/nova.proto", fileDescriptorNova) }

var fileDescriptorNova = []byte{
	// 1135 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x8f, 0xdb, 0x44,
	0x10, 0xc7, 0x49, 0x9c, 0x38, 0x93, 0x3f, 0x6d, 0x97, 0x42, 0xdd, 0x6b, 0x9b, 0x46, 0xe1, 0xdf,
	0x81, 0x50, 0x2a, 0xae, 0xe8, 0xd4, 0x2b, 0x48, 0xa8, 0xa8, 0x3d, 0x14, 0x04, 0xa7, 0xc8, 0x54,
	0x42, 0xf0, 0x80, 0xb5, 0x67, 0x6f, 0x72, 0xab, 0x24, 0xb6, 0xb5, 0xbb, 0x4e, 0x2f, 0xef, 0x7c,
	0x08, 0xbe, 0x00, 0x5f, 0x82, 0x47, 0x9e, 0x78, 0xe0, 0x81, 0x2f, 0x80, 0x84, 0x8e, 0x37, 0x3e,
	0x05, 0xda, 0x59, 0x3b, 0xb5, 0xef, 0x92, 0x50, 0x5e, 0xa2, 0x99, 0xd9, 0x99, 0x5f, 0x66, 0xe6,
	0x37, 0xb3, 0x6b, 0xb8, 0x1d, 0x27, 0x2c, 0x92, 0x8a, 0x06, 0xb3, 0x07, 0x51, 0xbc, 0xa4, 0xf8,
	0x33, 0x4c, 0x44, 0xac, 0x62, 0xf2, 0x06, 0x0b, 0xce, 0xe2, 0xe4, 0x74, 0xb8, 0xf6, 0x18, 0xea,
	0xc3, 0xc1, 0x2f, 0x16, 0xd4, 0x8f, 0xe7, 0x74, 0x19, 0x0b, 0xd2, 0x85, 0x0a, 0x0f, 0x5d, 0xab,
	0x6f, 0xed, 0x37, 0xbd, 0x0a, 0x0f, 0x09, 0x81, 0x5a, 0xc8, 0xe5, 0xcc, 0xad, 0xf4, 0xad, 0x7d,
	0xdb, 0x43, 0x99, 0x5c, 0x87, 0xaa, 0xa0, 0x0b, 0xb7, 0x8a, 0x26, 0x2d, 0x6a, 0xaf, 0x88, 0x2e,
	0x98, 0x5b, 0xc3, 0x38, 0x94, 0xc9, 0x7d, 0x68, 0x89, 0x73, 0x75, 0xee, 0x4f, 0x68, 0xa0, 0x62,
	0xe1, 0xda, 0x7d, 0x6b, 0xdf, 0xf2, 0x40, 0x9b, 0x8e, 0xd1, 0xa2, 0x83, 0xe4, 0x0b, 0x9a, 0xb8,
	0x75, 0x03, 0xad, 0x65, 0x72, 0x13, 0xec, 0x65, 0x90, 0xa4, 0xd2, 0x6d, 0xa0, 0xd1, 0x28, 0xe4,
	0x0e, 0x34, 0xb9, 0xf4, 0x93, 0xf4, 0x74, 0xce, 0x03, 0xd7, 0xe9, 0x5b, 0xfb, 0x8e, 0xe7, 0x70,
	0x39, 0x46, 0x7d, 0xf0, 0x7b, 0x05, 0xec, 0xd1, 0x82, 0x4e, 0xd9, 0x95, 0xdc, 0x5d, 0x68, 0x04,
	0x82, 0x51, 0xc5, 0x42, 0x4c, 0xbf, 0xe9, 0xe5, 0x2a, 0xb9, 0x0d, 0xce, 0x82, 0x47, 0x3e, 0x56,
	0x66, 0xca, 0x68, 0x2c, 0x78, 0xf4, 0x54, 0x17, 0x77, 0x0b, 0xb4, 0xe8, 0xeb, 0x02, 0x6b, 0x78,
	0x52, 0x5f, 0xf0, 0xc8, 0x2b, 0xd4, 0x68, 0x17, 0x6a, 0xdc, 0x03, 0x27, 0x11, 0xf1, 0x54, 0x30,
	0x29, 0xb3, 0x32, 0xd6, 0x3a, 0x79, 0x13, 0xea, 0x52, 0x51, 0x95, 0xd5, 0xd2, 0xf4, 0x32, 0x4d,
	0x67, 0x95, 0x26, 0x21, 0x66, 0xe5, 0x98, 0xac, 0x32, 0x95, 0x1c, 0x83, 0xb3, 0x60, 0x8a, 0x86,
	0x54, 0x51, 0xb7, 0xd9, 0xaf, 0xee, 0xb7, 0x0e, 0x3e, 0x18, 0x6e, 0x24, 0x6c, 0x88, 0xf5, 0x0e,
	0xbf, 0xce, 0x9c, 0x9f, 0x45, 0x4a, 0xac, 0xbc, 0x75, 0xec, 0xde, 0x27, 0xd0, 0x29, 0x1d, 0x69,
	0xc2, 0x66, 0x6c, 0x95, 0x75, 0x46, 0x8b, 0xd8, 0x67, 0x3a, 0x4f, 0x59, 0xd6, 0x18, 0xa3, 0x3c,
	0xae, 0x3c, 0xb2, 0x06, 0xbf, 0x3a, 0x50, 0xff, 0x86, 0x89, 0x25, 0xbb, 0x3a, 0x0b, 0x77, 0xa0,
	0xa9, 0x58, 0x44, 0x23, 0xe5, 0xf3, 0xbc, 0xa3, 0x8e, 0x31, 0x8c, 0x42, 0xdd, 0xb7, 0x54, 0x32,
	0xa1, 0x8f, 0xaa, 0xa6, 0x5e, 0xad, 0x8e, 0xc2, 0x8d, 0xb3, 0x51, 0xe8, 0x81, 0x5d, 0xee, 0x41,
	0x81, 0xb3, 0x7a, 0x99, 0xb3, 0x5b, 0xd0, 0x38, 0x8b, 0x25, 0xfe, 0x77, 0xd6, 0x50, 0xad, 0x8e,
	0xc2, 0x42, 0xa3, 0x9d, 0x52, 0xa3, 0x8b, 0xe4, 0x34, 0x2f, 0x91, 0xd3, 0x03, 0xa0, 0x41, 0xc0,
	0xa4, 0x1c, 0x8d, 0x97, 0x1f, 0xbb, 0x80, 0x71, 0x05, 0x4b, 0xe9, 0xfc, 0xd0, 0x6d, 0x5d, 0x3a,
	0x3f, 0x24, 0x4f, 0xa0, 0xce, 0x35, 0x07, 0xd2, 0x6d, 0x23, 0x51, 0xef, 0x6f, 0x21, 0xca, 0x74,
	0xd2, 0xf0, 0x25, 0x0d, 0x4f, 0x59, 0x20, 0x79, 0x0a, 0x8d, 0x09, 0xee, 0x9c, 0x74, 0x3b, 0x3b,
	0xc9, 0xce, 0x30, 0xcc, 0x82, 0x66, 0x20, 0x79, 0x28, 0xf9, 0x12, 0x9a, 0x34, 0x0c, 0x75, 0x4d,
	0x4c, 0xba, 0x5d, 0xc4, 0xf9, 0x70, 0x37, 0xce, 0x93, 0xdc, 0xdd, 0x20, 0xbd, 0x0c, 0x27, 0xcf,
	0xa1, 0x93, 0xcf, 0x90, 0xcf, 0xa3, 0x49, 0xec, 0x5e, 0x43, 0xbc, 0x07, 0xbb, 0xf1, 0xf2, 0x51,
	0x1b, 0x45, 0x93, 0xd8, 0x40, 0xb6, 0x17, 0x05, 0x93, 0x1e, 0xb5, 0x39, 0x8f, 0x66, 0xd2, 0xbd,
	0xde, 0xaf, 0xea, 0x51, 0x43, 0x45, 0x6f, 0xe0, 0x8c, 0xad, 0x7c, 0x9c, 0x8c, 0x1b, 0x86, 0xe8,
	0x19, 0x5b, 0x9d, 0xe8, 0xe1, 0xb8, 0xab, 0x4b, 0x5a, 0xf0, 0x68, 0x4c, 0xa5, 0x74, 0x09, 0x9e,
	0xbd, 0x34, 0x90, 0x13, 0xb8, 0x26, 0x59, 0x90, 0x0a, 0xae, 0x56, 0xfe, 0x54, 0xc4, 0x69, 0x22,
	0xdd, 0x9b, 0x98, 0xe6, 0x3b, 0x5b, 0xd3, 0x34, 0xde, 0x5f, 0xa0, 0xb3, 0xd7, 0x95, 0x25, 0x7d,
	0xef, 0x5b, 0x68, 0x15, 0xd8, 0xd9, 0xb0, 0x2a, 0x07, 0xc5, 0x55, 0x69, 0x1d, 0xdc, 0xdd, 0xb5,
	0x92, 0x85, 0x45, 0xda, 0xfb, 0x0e, 0xda, 0x45, 0xca, 0x36, 0x20, 0x3f, 0x2c, 0x23, 0xdf, 0xdb,
	0x82, 0x6c, 0x50, 0x8a, 0xd0, 0x3f, 0x40, 0xb7, 0xcc, 0xe2, 0x06, 0xf0, 0xc3, 0x32, 0x78, 0x7f,
	0x0b, 0xf8, 0x1a, 0xa7, 0x88, 0xff, 0x19, 0xdc, 0xb8, 0xc2, 0xea, 0xff, 0xba, 0x44, 0xbe, 0x82,
	0xc6, 0x09, 0x53, 0x2f, 0x62, 0x31, 0xd3, 0xeb, 0x9f, 0xa6, 0xeb, 0x6b, 0x04, 0x65, 0x6d, 0x4b,
	0x62, 0xa1, 0xb2, 0x38, 0x94, 0xf5, 0x40, 0x4c, 0xf8, 0x39, 0x0b, 0x7d, 0x9e, 0x64, 0x17, 0x48,
	0x03, 0xf5, 0x51, 0x32, 0x38, 0x84, 0xda, 0x31, 0x9f, 0x33, 0x0c, 0xa3, 0xea, 0x2c, 0x87, 0xd2,
	0xb2, 0x5e, 0xf2, 0x20, 0x8e, 0x14, 0x8b, 0x94, 0x44, 0xb8, 0xb6, 0xb7, 0xd6, 0x07, 0x23, 0x68,
	0xae, 0xcb, 0x23, 0x9f, 0x16, 0x17, 0xc5, 0xc2, 0x89, 0xe9, 0xed, 0xee, 0x49, 0x61, 0x35, 0x06,
	0xff, 0x58, 0xd0, 0xc8, 0xcc, 0xfa, 0x8a, 0x5a, 0x32, 0x21, 0x79, 0x1c, 0x61, 0x26, 0xb6, 0x97,
	0xab, 0x3a, 0x41, 0x1d, 0x92, 0xd7, 0xa5, 0x65, 0x7c, 0x6a, 0x68, 0xe0, 0xa3, 0x3d, 0xab, 0x6b,
	0x41, 0x03, 0x8d, 0x45, 0xde, 0x82, 0x0e, 0x95, 0x92, 0x4f, 0x23, 0x16, 0xfa, 0x6a, 0x95, 0xe4,
	0x57, 0x64, 0x3b, 0x37, 0x3e, 0x5f, 0x25, 0x8c, 0x1c, 0x41, 0x95, 0x9d, 0x2b, 0xd7, 0xc6, 0x8c,
	0xdf, 0xdb, 0x9d, 0xf1, 0xf0, 0xd9, 0xb9, 0x32, 0x2b, 0xa8, 0x63, 0xf6, 0x0e, 0xc1, 0xc9, 0x0d,
	0xff, 0xc5, 0x5e, 0xbb, 0xc8, 0xde, 0x9f, 0x16, 0x74, 0xcb, 0x5b, 0x43, 0x4e, 0xaf, 0x6e, 0x9d,
	0xe9, 0xe1, 0xd1, 0x2b, 0x6d, 0xdd, 0x25, 0xd5, 0xe4, 0x78, 0x79, 0x13, 0xa7, 0xf0, 0xfa, 0x06,
	0xb7, 0x0d, 0x99, 0x3f, 0x2e, 0x8f, 0xf6, 0xdb, 0xaf, 0x92, 0x42, 0xb1, 0xbe, 0x9f, 0x2d, 0xe8,
	0x94, 0x0e, 0x37, 0x7d, 0xf5, 0xe0, 0xcd, 0x54, 0x29, 0xbc, 0x59, 0x7d, 0x68, 0x85, 0x4c, 0x06,
	0x82, 0x27, 0x4a, 0x53, 0x6f, 0xb8, 0x2c, 0x9a, 0xc8, 0x47, 0x60, 0x8b, 0x74, 0xce, 0xa4, 0x5b,
	0xc3, 0xd6, 0xdc, 0xd9, 0x92, 0x97, 0x97, 0xce, 0x99, 0x67, 0x3c, 0xcb, 0x4f, 0xaa, 0x5d, 0x7e,
	0x52, 0x07, 0x3f, 0x56, 0xa0, 0xa6, 0x9d, 0x37, 0x3d, 0xc4, 0x13, 0x11, 0x2f, 0xfc, 0xf5, 0x12,
	0xd9, 0x9e, 0xa3, 0x0d, 0x63, 0xbd, 0x48, 0xb7, 0xa0, 0xa1, 0x62, 0x73, 0x64, 0x3e, 0x6d, 0xea,
	0x2a, 0xc6, 0x83, 0xfb, 0xd0, 0xe2, 0x89, 0x8f, 0x1f, 0x82, 0x41, 0x3c, 0xcf, 0x86, 0x0d, 0x78,
	0x32, 0xce, 0x2c, 0xe4, 0x08, 0x1c, 0x9e, 0xf8, 0x82, 0x46, 0x53, 0xf3, 0x95, 0xb3, 0x7d, 0x43,
	0x46, 0x63, 0x4f, 0x7b, 0x79, 0x0d, 0x9e, 0xa0, 0x40, 0xde, 0x85, 0x6b, 0x09, 0x15, 0x2c, 0x52,
	0x66, 0x3a, 0x74, 0x35, 0xe6, 0xf9, 0xee, 0x18, 0x33, 0xb6, 0x79, 0x14, 0xea, 0xcb, 0x14, 0x1d,
	0xf0, 0x09, 0xdf, 0x7e, 0x99, 0x66, 0x94, 0xa1, 0xeb, 0xe0, 0x1e, 0x34, 0xb2, 0xff, 0xd3, 0xbc,
	0x04, 0x3c, 0x14, 0xf9, 0x0d, 0xa0, 0xe5, 0xc1, 0x23, 0xb0, 0x0d, 0x89, 0xa5, 0x5e, 0x5a, 0x97,
	0x3e, 0x4f, 0x36, 0x30, 0xfa, 0x79, 0xff, 0xb7, 0x8b, 0x9e, 0xf5, 0xc7, 0x45, 0xcf, 0xfa, 0xeb,
	0xa2, 0x67, 0xfd, 0xf4, 0x77, 0xef, 0xb5, 0xef, 0xbb, 0xe5, 0x4f, 0xe7, 0xd3, 0x3a, 0x76, 0xeb,
	0xe1, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x83, 0x11, 0x0b, 0x7c, 0x53, 0x0b, 0x00, 0x00,
}
