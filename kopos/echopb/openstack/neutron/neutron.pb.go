// Code generated by protoc-gen-gogo.
// source: openstack/neutron/neutron.proto
// DO NOT EDIT!

/*
	Package neutron is a generated protocol buffer package.

	It is generated from these files:
		openstack/neutron/neutron.proto

	It has these top-level messages:
		FloatingIP
		NetworkExternal
		GatewayInfo
		Route
		Router
		InterfaceInfo
		PortBinding
		NetworkExtAttrs
		SecGroup
		SecGroupRule
		Network
		IP
		AddressPair
		Port
		HostRoute
		AllocationPool
		Subnet
*/
package neutron

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// FloatingIP represents a floating IP resource. A floating IP is an external
// IP address that is mapped to an internal port and, optionally, a specific
// IP address on a private network. In other words, it enables access to an
// instance on a private network from an external network. For this reason,
// floating IPs can only be defined on networks where the 'router:external'
// attribute (provided by the external network extension) is set to True.
type FloatingIP struct {
	// Unique identifier for the floating IP instance.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// UUID of the external network where the floating IP is to be created.
	FloatingNetworkId string `protobuf:"bytes,2,opt,name=floating_network_id,json=floatingNetworkId,proto3" json:"floating_network_id,omitempty"`
	// Address of the floating IP on the external network.
	FloatingIpAddress string `protobuf:"bytes,3,opt,name=floating_ip_address,json=floatingIpAddress,proto3" json:"floating_ip_address,omitempty"`
	// UUID of the port on an internal network that is associated with the floating IP.
	PortId string `protobuf:"bytes,4,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// The specific IP address of the internal port which should be associated
	// with the floating IP.
	FixedIpAddress string `protobuf:"bytes,5,opt,name=fixed_ip_address,json=fixedIpAddress,proto3" json:"fixed_ip_address,omitempty"`
	// Owner of the floating IP. Only admin users can specify a tenant identifier
	// other than its own.
	TenantId string `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// The condition of the API resource.
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// The ID of the router used for this Floating-IP
	RouterId string `protobuf:"bytes,8,opt,name=router_id,json=routerId,proto3" json:"router_id,omitempty"`
}

func (m *FloatingIP) Reset()                    { *m = FloatingIP{} }
func (m *FloatingIP) String() string            { return proto.CompactTextString(m) }
func (*FloatingIP) ProtoMessage()               {}
func (*FloatingIP) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{0} }

func (m *FloatingIP) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FloatingIP) GetFloatingNetworkId() string {
	if m != nil {
		return m.FloatingNetworkId
	}
	return ""
}

func (m *FloatingIP) GetFloatingIpAddress() string {
	if m != nil {
		return m.FloatingIpAddress
	}
	return ""
}

func (m *FloatingIP) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *FloatingIP) GetFixedIpAddress() string {
	if m != nil {
		return m.FixedIpAddress
	}
	return ""
}

func (m *FloatingIP) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *FloatingIP) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *FloatingIP) GetRouterId() string {
	if m != nil {
		return m.RouterId
	}
	return ""
}

type NetworkExternal struct {
	Network  *Network `protobuf:"bytes,1,opt,name=network" json:"network,omitempty"`
	External bool     `protobuf:"varint,2,opt,name=external,proto3" json:"external,omitempty"`
}

func (m *NetworkExternal) Reset()                    { *m = NetworkExternal{} }
func (m *NetworkExternal) String() string            { return proto.CompactTextString(m) }
func (*NetworkExternal) ProtoMessage()               {}
func (*NetworkExternal) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{1} }

func (m *NetworkExternal) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *NetworkExternal) GetExternal() bool {
	if m != nil {
		return m.External
	}
	return false
}

type GatewayInfo struct {
	NetworkId string `protobuf:"bytes,1,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
}

func (m *GatewayInfo) Reset()                    { *m = GatewayInfo{} }
func (m *GatewayInfo) String() string            { return proto.CompactTextString(m) }
func (*GatewayInfo) ProtoMessage()               {}
func (*GatewayInfo) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{2} }

func (m *GatewayInfo) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

type Route struct {
	NextHop         string `protobuf:"bytes,1,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	DestinationCidr string `protobuf:"bytes,2,opt,name=destination_cidr,json=destinationCidr,proto3" json:"destination_cidr,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{3} }

func (m *Route) GetNextHop() string {
	if m != nil {
		return m.NextHop
	}
	return ""
}

func (m *Route) GetDestinationCidr() string {
	if m != nil {
		return m.DestinationCidr
	}
	return ""
}

type Router struct {
	Status       string       `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	GatewayInfo  *GatewayInfo `protobuf:"bytes,2,opt,name=gateway_info,json=gatewayInfo" json:"gateway_info,omitempty"`
	AdminStateUp bool         `protobuf:"varint,3,opt,name=admin_state_up,json=adminStateUp,proto3" json:"admin_state_up,omitempty"`
	Distributed  bool         `protobuf:"varint,4,opt,name=distributed,proto3" json:"distributed,omitempty"`
	Name         string       `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Id           string       `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
	TenantId     string       `protobuf:"bytes,7,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Routes       []*Route     `protobuf:"bytes,8,rep,name=routes" json:"routes,omitempty"`
}

func (m *Router) Reset()                    { *m = Router{} }
func (m *Router) String() string            { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()               {}
func (*Router) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{4} }

func (m *Router) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Router) GetGatewayInfo() *GatewayInfo {
	if m != nil {
		return m.GatewayInfo
	}
	return nil
}

func (m *Router) GetAdminStateUp() bool {
	if m != nil {
		return m.AdminStateUp
	}
	return false
}

func (m *Router) GetDistributed() bool {
	if m != nil {
		return m.Distributed
	}
	return false
}

func (m *Router) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Router) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Router) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Router) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

// InterfaceInfo represents information about a particular router interface. As
// mentioned above, in order for a router to forward to a subnet, it needs an
// interface.
type InterfaceInfo struct {
	// The ID of the subnet which this interface is associated with.
	SubnetId string `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// The ID of the port that is a part of the subnet.
	PortId string `protobuf:"bytes,2,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty"`
	// The UUID of the interface.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// Owner of the interface.
	TenantId string `protobuf:"bytes,4,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *InterfaceInfo) Reset()                    { *m = InterfaceInfo{} }
func (m *InterfaceInfo) String() string            { return proto.CompactTextString(m) }
func (*InterfaceInfo) ProtoMessage()               {}
func (*InterfaceInfo) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{5} }

func (m *InterfaceInfo) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *InterfaceInfo) GetPortId() string {
	if m != nil {
		return m.PortId
	}
	return ""
}

func (m *InterfaceInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InterfaceInfo) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

type PortBinding struct {
	Port   *Port  `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	HostId string `protobuf:"bytes,2,opt,name=host_id,json=hostId,proto3" json:"host_id,omitempty"`
	// map<string, google.protobuf.Any> vif_details = 3;
	VifDetails map[string][]byte `protobuf:"bytes,3,rep,name=vif_details,json=vifDetails" json:"vif_details,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	VifType    string            `protobuf:"bytes,4,opt,name=vif_type,json=vifType,proto3" json:"vif_type,omitempty"`
	VnicType   string            `protobuf:"bytes,5,opt,name=vnic_type,json=vnicType,proto3" json:"vnic_type,omitempty"`
	Profile    map[string]string `protobuf:"bytes,6,rep,name=profile" json:"profile,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PortBinding) Reset()                    { *m = PortBinding{} }
func (m *PortBinding) String() string            { return proto.CompactTextString(m) }
func (*PortBinding) ProtoMessage()               {}
func (*PortBinding) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{6} }

func (m *PortBinding) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *PortBinding) GetHostId() string {
	if m != nil {
		return m.HostId
	}
	return ""
}

func (m *PortBinding) GetVifDetails() map[string][]byte {
	if m != nil {
		return m.VifDetails
	}
	return nil
}

func (m *PortBinding) GetVifType() string {
	if m != nil {
		return m.VifType
	}
	return ""
}

func (m *PortBinding) GetVnicType() string {
	if m != nil {
		return m.VnicType
	}
	return ""
}

func (m *PortBinding) GetProfile() map[string]string {
	if m != nil {
		return m.Profile
	}
	return nil
}

type NetworkExtAttrs struct {
	Id              string                     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name            string                     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	AdminStateUp    bool                       `protobuf:"varint,3,opt,name=admin_state_up,json=adminStateUp,proto3" json:"admin_state_up,omitempty"`
	Status          string                     `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Subnets         []*Subnet                  `protobuf:"bytes,5,rep,name=subnets" json:"subnets,omitempty"`
	TenantId        string                     `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	Shared          bool                       `protobuf:"varint,7,opt,name=shared,proto3" json:"shared,omitempty"`
	NetworkType     string                     `protobuf:"bytes,8,opt,name=network_type,json=networkType,proto3" json:"network_type,omitempty"`
	PhysicalNetwork string                     `protobuf:"bytes,9,opt,name=physical_network,json=physicalNetwork,proto3" json:"physical_network,omitempty"`
	SegmentationId  string                     `protobuf:"bytes,10,opt,name=segmentation_id,json=segmentationId,proto3" json:"segmentation_id,omitempty"`
	Segments        []*NetworkExtAttrs_Segment `protobuf:"bytes,11,rep,name=segments" json:"segments,omitempty"`
}

func (m *NetworkExtAttrs) Reset()                    { *m = NetworkExtAttrs{} }
func (m *NetworkExtAttrs) String() string            { return proto.CompactTextString(m) }
func (*NetworkExtAttrs) ProtoMessage()               {}
func (*NetworkExtAttrs) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{7} }

func (m *NetworkExtAttrs) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkExtAttrs) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkExtAttrs) GetAdminStateUp() bool {
	if m != nil {
		return m.AdminStateUp
	}
	return false
}

func (m *NetworkExtAttrs) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *NetworkExtAttrs) GetSubnets() []*Subnet {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *NetworkExtAttrs) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *NetworkExtAttrs) GetShared() bool {
	if m != nil {
		return m.Shared
	}
	return false
}

func (m *NetworkExtAttrs) GetNetworkType() string {
	if m != nil {
		return m.NetworkType
	}
	return ""
}

func (m *NetworkExtAttrs) GetPhysicalNetwork() string {
	if m != nil {
		return m.PhysicalNetwork
	}
	return ""
}

func (m *NetworkExtAttrs) GetSegmentationId() string {
	if m != nil {
		return m.SegmentationId
	}
	return ""
}

func (m *NetworkExtAttrs) GetSegments() []*NetworkExtAttrs_Segment {
	if m != nil {
		return m.Segments
	}
	return nil
}

type NetworkExtAttrs_Segment struct {
	PhysicalNetwork string `protobuf:"bytes,1,opt,name=physical_network,json=physicalNetwork,proto3" json:"physical_network,omitempty"`
	NetworkType     string `protobuf:"bytes,2,opt,name=network_type,json=networkType,proto3" json:"network_type,omitempty"`
	SegmentationId  string `protobuf:"bytes,3,opt,name=segmentation_id,json=segmentationId,proto3" json:"segmentation_id,omitempty"`
}

func (m *NetworkExtAttrs_Segment) Reset()         { *m = NetworkExtAttrs_Segment{} }
func (m *NetworkExtAttrs_Segment) String() string { return proto.CompactTextString(m) }
func (*NetworkExtAttrs_Segment) ProtoMessage()    {}
func (*NetworkExtAttrs_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptorNeutron, []int{7, 0}
}

func (m *NetworkExtAttrs_Segment) GetPhysicalNetwork() string {
	if m != nil {
		return m.PhysicalNetwork
	}
	return ""
}

func (m *NetworkExtAttrs_Segment) GetNetworkType() string {
	if m != nil {
		return m.NetworkType
	}
	return ""
}

func (m *NetworkExtAttrs_Segment) GetSegmentationId() string {
	if m != nil {
		return m.SegmentationId
	}
	return ""
}

// SecGroup represents a container for security group rules.
type SecGroup struct {
	// The UUID for the security group.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable name for the security group. Might not be unique. Cannot be
	// named "default" as that is automatically created for a tenant.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The security group description.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// A slice of security group rules that dictate the permitted behaviour for
	// traffic entering and leaving the group.
	SecurityGroupRules []*SecGroupRule `protobuf:"bytes,4,rep,name=security_group_rules,json=securityGroupRules" json:"security_group_rules,omitempty"`
	// Owner of the security group. Only admin users can specify a TenantID
	// other than their own.
	TenantId string `protobuf:"bytes,5,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *SecGroup) Reset()                    { *m = SecGroup{} }
func (m *SecGroup) String() string            { return proto.CompactTextString(m) }
func (*SecGroup) ProtoMessage()               {}
func (*SecGroup) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{8} }

func (m *SecGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SecGroup) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecGroup) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SecGroup) GetSecurityGroupRules() []*SecGroupRule {
	if m != nil {
		return m.SecurityGroupRules
	}
	return nil
}

func (m *SecGroup) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

// SecGroupRule represents a rule to dictate the behaviour of incoming or
// outgoing traffic for a particular security group.
type SecGroupRule struct {
	// The UUID for this security group rule.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The direction in which the security group rule is applied. The only values
	// allowed are "ingress" or "egress". For a compute instance, an ingress
	// security group rule is applied to incoming (ingress) traffic for that
	// instance. An egress rule is applied to traffic leaving the instance.
	Direction string `protobuf:"bytes,2,opt,name=direction,proto3" json:"direction,omitempty"`
	// Must be IPv4 or IPv6, and addresses represented in CIDR must match the
	// ingress or egress rules.
	// EtherType string json:"ethertype"
	Ethertype string `protobuf:"bytes,3,opt,name=ethertype,proto3" json:"ethertype,omitempty"`
	// The security group ID to associate with this security group rule.
	SecurityGroupId string `protobuf:"bytes,4,opt,name=security_group_id,json=securityGroupId,proto3" json:"security_group_id,omitempty"`
	// The minimum port number in the range that is matched by the security group
	// rule. If the protocol is TCP or UDP, this value must be less than or equal
	// to the value of the PortRangeMax attribute. If the protocol is ICMP, this
	// value must be an ICMP type.
	PortRangeMin int32 `protobuf:"varint,5,opt,name=port_range_min,json=portRangeMin,proto3" json:"port_range_min,omitempty"`
	// The maximum port number in the range that is matched by the security group
	// rule. The PortRangeMin attribute constrains the PortRangeMax attribute. If
	// the protocol is ICMP, this value must be an ICMP type.
	PortRangeMax int32 `protobuf:"varint,6,opt,name=port_range_max,json=portRangeMax,proto3" json:"port_range_max,omitempty"`
	// The protocol that is matched by the security group rule. Valid values are
	// "tcp", "udp", "icmp" or an empty string.
	Protocol string `protobuf:"bytes,7,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// The remote group ID to be associated with this security group rule. You
	// can specify either RemoteGroupID or RemoteIPPrefix.
	RemoteGroupId string `protobuf:"bytes,8,opt,name=remote_group_id,json=remoteGroupId,proto3" json:"remote_group_id,omitempty"`
	// The remote IP prefix to be associated with this security group rule. You
	// can specify either RemoteGroupID or RemoteIPPrefix . This attribute
	// matches the specified IP prefix as the source IP address of the IP packet.
	RemoteIpPrefix string `protobuf:"bytes,9,opt,name=remote_ip_prefix,json=remoteIpPrefix,proto3" json:"remote_ip_prefix,omitempty"`
	// The owner of this security group rule.
	TenantId string `protobuf:"bytes,10,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *SecGroupRule) Reset()                    { *m = SecGroupRule{} }
func (m *SecGroupRule) String() string            { return proto.CompactTextString(m) }
func (*SecGroupRule) ProtoMessage()               {}
func (*SecGroupRule) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{9} }

func (m *SecGroupRule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SecGroupRule) GetDirection() string {
	if m != nil {
		return m.Direction
	}
	return ""
}

func (m *SecGroupRule) GetEthertype() string {
	if m != nil {
		return m.Ethertype
	}
	return ""
}

func (m *SecGroupRule) GetSecurityGroupId() string {
	if m != nil {
		return m.SecurityGroupId
	}
	return ""
}

func (m *SecGroupRule) GetPortRangeMin() int32 {
	if m != nil {
		return m.PortRangeMin
	}
	return 0
}

func (m *SecGroupRule) GetPortRangeMax() int32 {
	if m != nil {
		return m.PortRangeMax
	}
	return 0
}

func (m *SecGroupRule) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *SecGroupRule) GetRemoteGroupId() string {
	if m != nil {
		return m.RemoteGroupId
	}
	return ""
}

func (m *SecGroupRule) GetRemoteIpPrefix() string {
	if m != nil {
		return m.RemoteIpPrefix
	}
	return ""
}

func (m *SecGroupRule) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

// Network represents, well, a network.
type Network struct {
	// UUID for the network
	// ID string json:"id"
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable name for the network. Might not be unique.
	// Name string json:"name"
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The administrative state of network. If false (down), the network does not forward packets.
	// AdminStateUp bool json:"admin_state_up"
	AdminStateUp bool `protobuf:"varint,3,opt,name=admin_state_up,json=adminStateUp,proto3" json:"admin_state_up,omitempty"`
	// Indicates whether network is currently operational. Possible values include
	// 'ACTIVE', 'DOWN', 'BUILD', or 'ERROR'. Plug-ins might define additional values.
	// Status string json:"status"
	Status string `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	// Subnets associated with this network.
	// Subnets []string json:"subnets"
	Subnets []*Subnet `protobuf:"bytes,5,rep,name=subnets" json:"subnets,omitempty"`
	// Owner of network. Only admin users can specify a tenant_id other than its own.
	// TenantID string json:"tenant_id"
	TenantId string `protobuf:"bytes,6,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	// Specifies whether the network resource can be accessed by any tenant or not.
	// Shared bool json:"shared"
	Shared bool `protobuf:"varint,7,opt,name=shared,proto3" json:"shared,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{10} }

func (m *Network) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetAdminStateUp() bool {
	if m != nil {
		return m.AdminStateUp
	}
	return false
}

func (m *Network) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Network) GetSubnets() []*Subnet {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *Network) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Network) GetShared() bool {
	if m != nil {
		return m.Shared
	}
	return false
}

type IP struct {
	SubnetId  string `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	IpAddress string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
}

func (m *IP) Reset()                    { *m = IP{} }
func (m *IP) String() string            { return proto.CompactTextString(m) }
func (*IP) ProtoMessage()               {}
func (*IP) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{11} }

func (m *IP) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *IP) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

type AddressPair struct {
	IpAddress  string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	MacAddress string `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
}

func (m *AddressPair) Reset()                    { *m = AddressPair{} }
func (m *AddressPair) String() string            { return proto.CompactTextString(m) }
func (*AddressPair) ProtoMessage()               {}
func (*AddressPair) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{12} }

func (m *AddressPair) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *AddressPair) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

type Port struct {
	Id                  string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	NetworkId           string         `protobuf:"bytes,2,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	Name                string         `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	AdminStateUp        bool           `protobuf:"varint,4,opt,name=admin_state_up,json=adminStateUp,proto3" json:"admin_state_up,omitempty"`
	Status              string         `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	MacAddress          string         `protobuf:"bytes,6,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	FixedIps            []*IP          `protobuf:"bytes,7,rep,name=fixed_ips,json=fixedIps" json:"fixed_ips,omitempty"`
	TenantId            string         `protobuf:"bytes,8,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	DeviceOwner         string         `protobuf:"bytes,9,opt,name=device_owner,json=deviceOwner,proto3" json:"device_owner,omitempty"`
	SecurityGroups      []string       `protobuf:"bytes,10,rep,name=security_groups,json=securityGroups" json:"security_groups,omitempty"`
	DeviceId            string         `protobuf:"bytes,11,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	AllowedAddressPairs []*AddressPair `protobuf:"bytes,12,rep,name=allowed_address_pairs,json=allowedAddressPairs" json:"allowed_address_pairs,omitempty"`
}

func (m *Port) Reset()                    { *m = Port{} }
func (m *Port) String() string            { return proto.CompactTextString(m) }
func (*Port) ProtoMessage()               {}
func (*Port) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{13} }

func (m *Port) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Port) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Port) GetAdminStateUp() bool {
	if m != nil {
		return m.AdminStateUp
	}
	return false
}

func (m *Port) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Port) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *Port) GetFixedIps() []*IP {
	if m != nil {
		return m.FixedIps
	}
	return nil
}

func (m *Port) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Port) GetDeviceOwner() string {
	if m != nil {
		return m.DeviceOwner
	}
	return ""
}

func (m *Port) GetSecurityGroups() []string {
	if m != nil {
		return m.SecurityGroups
	}
	return nil
}

func (m *Port) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *Port) GetAllowedAddressPairs() []*AddressPair {
	if m != nil {
		return m.AllowedAddressPairs
	}
	return nil
}

type HostRoute struct {
	DestinationCidr string `protobuf:"bytes,1,opt,name=destination_cidr,json=destinationCidr,proto3" json:"destination_cidr,omitempty"`
	NextHop         string `protobuf:"bytes,2,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
}

func (m *HostRoute) Reset()                    { *m = HostRoute{} }
func (m *HostRoute) String() string            { return proto.CompactTextString(m) }
func (*HostRoute) ProtoMessage()               {}
func (*HostRoute) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{14} }

func (m *HostRoute) GetDestinationCidr() string {
	if m != nil {
		return m.DestinationCidr
	}
	return ""
}

func (m *HostRoute) GetNextHop() string {
	if m != nil {
		return m.NextHop
	}
	return ""
}

type AllocationPool struct {
	Start string `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *AllocationPool) Reset()                    { *m = AllocationPool{} }
func (m *AllocationPool) String() string            { return proto.CompactTextString(m) }
func (*AllocationPool) ProtoMessage()               {}
func (*AllocationPool) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{15} }

func (m *AllocationPool) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *AllocationPool) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

type Subnet struct {
	Id              string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	NetworkId       string            `protobuf:"bytes,2,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	Name            string            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	IpVersion       int32             `protobuf:"varint,4,opt,name=ip_version,json=ipVersion,proto3" json:"ip_version,omitempty"`
	Cidr            string            `protobuf:"bytes,5,opt,name=cidr,proto3" json:"cidr,omitempty"`
	GatewayIp       string            `protobuf:"bytes,6,opt,name=gateway_ip,json=gatewayIp,proto3" json:"gateway_ip,omitempty"`
	DnsNameServers  []string          `protobuf:"bytes,7,rep,name=dns_name_servers,json=dnsNameServers" json:"dns_name_servers,omitempty"`
	AllocationPools []*AllocationPool `protobuf:"bytes,8,rep,name=allocation_pools,json=allocationPools" json:"allocation_pools,omitempty"`
	HostRoutes      []*HostRoute      `protobuf:"bytes,9,rep,name=host_routes,json=hostRoutes" json:"host_routes,omitempty"`
	EnableDhcp      bool              `protobuf:"varint,10,opt,name=enable_dhcp,json=enableDhcp,proto3" json:"enable_dhcp,omitempty"`
	TenantId        string            `protobuf:"bytes,11,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
}

func (m *Subnet) Reset()                    { *m = Subnet{} }
func (m *Subnet) String() string            { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()               {}
func (*Subnet) Descriptor() ([]byte, []int) { return fileDescriptorNeutron, []int{16} }

func (m *Subnet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Subnet) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *Subnet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subnet) GetIpVersion() int32 {
	if m != nil {
		return m.IpVersion
	}
	return 0
}

func (m *Subnet) GetCidr() string {
	if m != nil {
		return m.Cidr
	}
	return ""
}

func (m *Subnet) GetGatewayIp() string {
	if m != nil {
		return m.GatewayIp
	}
	return ""
}

func (m *Subnet) GetDnsNameServers() []string {
	if m != nil {
		return m.DnsNameServers
	}
	return nil
}

func (m *Subnet) GetAllocationPools() []*AllocationPool {
	if m != nil {
		return m.AllocationPools
	}
	return nil
}

func (m *Subnet) GetHostRoutes() []*HostRoute {
	if m != nil {
		return m.HostRoutes
	}
	return nil
}

func (m *Subnet) GetEnableDhcp() bool {
	if m != nil {
		return m.EnableDhcp
	}
	return false
}

func (m *Subnet) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func init() {
	proto.RegisterType((*FloatingIP)(nil), "echopb.openstack.neutron.FloatingIP")
	proto.RegisterType((*NetworkExternal)(nil), "echopb.openstack.neutron.NetworkExternal")
	proto.RegisterType((*GatewayInfo)(nil), "echopb.openstack.neutron.GatewayInfo")
	proto.RegisterType((*Route)(nil), "echopb.openstack.neutron.Route")
	proto.RegisterType((*Router)(nil), "echopb.openstack.neutron.Router")
	proto.RegisterType((*InterfaceInfo)(nil), "echopb.openstack.neutron.InterfaceInfo")
	proto.RegisterType((*PortBinding)(nil), "echopb.openstack.neutron.PortBinding")
	proto.RegisterType((*NetworkExtAttrs)(nil), "echopb.openstack.neutron.NetworkExtAttrs")
	proto.RegisterType((*NetworkExtAttrs_Segment)(nil), "echopb.openstack.neutron.NetworkExtAttrs.Segment")
	proto.RegisterType((*SecGroup)(nil), "echopb.openstack.neutron.SecGroup")
	proto.RegisterType((*SecGroupRule)(nil), "echopb.openstack.neutron.SecGroupRule")
	proto.RegisterType((*Network)(nil), "echopb.openstack.neutron.Network")
	proto.RegisterType((*IP)(nil), "echopb.openstack.neutron.IP")
	proto.RegisterType((*AddressPair)(nil), "echopb.openstack.neutron.AddressPair")
	proto.RegisterType((*Port)(nil), "echopb.openstack.neutron.Port")
	proto.RegisterType((*HostRoute)(nil), "echopb.openstack.neutron.HostRoute")
	proto.RegisterType((*AllocationPool)(nil), "echopb.openstack.neutron.AllocationPool")
	proto.RegisterType((*Subnet)(nil), "echopb.openstack.neutron.Subnet")
}
func (m *FloatingIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatingIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.FloatingNetworkId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.FloatingNetworkId)))
		i += copy(dAtA[i:], m.FloatingNetworkId)
	}
	if len(m.FloatingIpAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.FloatingIpAddress)))
		i += copy(dAtA[i:], m.FloatingIpAddress)
	}
	if len(m.PortId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if len(m.FixedIpAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.FixedIpAddress)))
		i += copy(dAtA[i:], m.FixedIpAddress)
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.RouterId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.RouterId)))
		i += copy(dAtA[i:], m.RouterId)
	}
	return i, nil
}

func (m *NetworkExternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkExternal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Network != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.Network.Size()))
		n1, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.External {
		dAtA[i] = 0x10
		i++
		if m.External {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GatewayInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NetworkId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NetworkId)))
		i += copy(dAtA[i:], m.NetworkId)
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NextHop) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NextHop)))
		i += copy(dAtA[i:], m.NextHop)
	}
	if len(m.DestinationCidr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.DestinationCidr)))
		i += copy(dAtA[i:], m.DestinationCidr)
	}
	return i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.GatewayInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.GatewayInfo.Size()))
		n2, err := m.GatewayInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.AdminStateUp {
		dAtA[i] = 0x18
		i++
		if m.AdminStateUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Distributed {
		dAtA[i] = 0x20
		i++
		if m.Distributed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InterfaceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.PortId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.PortId)))
		i += copy(dAtA[i:], m.PortId)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	return i, nil
}

func (m *PortBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.Port.Size()))
		n3, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.HostId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.HostId)))
		i += copy(dAtA[i:], m.HostId)
	}
	if len(m.VifDetails) > 0 {
		for k, _ := range m.VifDetails {
			dAtA[i] = 0x1a
			i++
			v := m.VifDetails[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovNeutron(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovNeutron(uint64(len(k))) + byteSize
			i = encodeVarintNeutron(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintNeutron(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.VifType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.VifType)))
		i += copy(dAtA[i:], m.VifType)
	}
	if len(m.VnicType) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.VnicType)))
		i += copy(dAtA[i:], m.VnicType)
	}
	if len(m.Profile) > 0 {
		for k, _ := range m.Profile {
			dAtA[i] = 0x32
			i++
			v := m.Profile[k]
			mapSize := 1 + len(k) + sovNeutron(uint64(len(k))) + 1 + len(v) + sovNeutron(uint64(len(v)))
			i = encodeVarintNeutron(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *NetworkExtAttrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkExtAttrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AdminStateUp {
		dAtA[i] = 0x18
		i++
		if m.AdminStateUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if m.Shared {
		dAtA[i] = 0x38
		i++
		if m.Shared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.NetworkType) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NetworkType)))
		i += copy(dAtA[i:], m.NetworkType)
	}
	if len(m.PhysicalNetwork) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.PhysicalNetwork)))
		i += copy(dAtA[i:], m.PhysicalNetwork)
	}
	if len(m.SegmentationId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.SegmentationId)))
		i += copy(dAtA[i:], m.SegmentationId)
	}
	if len(m.Segments) > 0 {
		for _, msg := range m.Segments {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NetworkExtAttrs_Segment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkExtAttrs_Segment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhysicalNetwork) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.PhysicalNetwork)))
		i += copy(dAtA[i:], m.PhysicalNetwork)
	}
	if len(m.NetworkType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NetworkType)))
		i += copy(dAtA[i:], m.NetworkType)
	}
	if len(m.SegmentationId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.SegmentationId)))
		i += copy(dAtA[i:], m.SegmentationId)
	}
	return i, nil
}

func (m *SecGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.SecurityGroupRules) > 0 {
		for _, msg := range m.SecurityGroupRules {
			dAtA[i] = 0x22
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	return i, nil
}

func (m *SecGroupRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecGroupRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Direction) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Direction)))
		i += copy(dAtA[i:], m.Direction)
	}
	if len(m.Ethertype) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Ethertype)))
		i += copy(dAtA[i:], m.Ethertype)
	}
	if len(m.SecurityGroupId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.SecurityGroupId)))
		i += copy(dAtA[i:], m.SecurityGroupId)
	}
	if m.PortRangeMin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.PortRangeMin))
	}
	if m.PortRangeMax != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.PortRangeMax))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.RemoteGroupId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.RemoteGroupId)))
		i += copy(dAtA[i:], m.RemoteGroupId)
	}
	if len(m.RemoteIpPrefix) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.RemoteIpPrefix)))
		i += copy(dAtA[i:], m.RemoteIpPrefix)
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AdminStateUp {
		dAtA[i] = 0x18
		i++
		if m.AdminStateUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.Subnets) > 0 {
		for _, msg := range m.Subnets {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if m.Shared {
		dAtA[i] = 0x38
		i++
		if m.Shared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubnetId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.SubnetId)))
		i += copy(dAtA[i:], m.SubnetId)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	return i, nil
}

func (m *AddressPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	return i, nil
}

func (m *Port) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Port) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.NetworkId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NetworkId)))
		i += copy(dAtA[i:], m.NetworkId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.AdminStateUp {
		dAtA[i] = 0x20
		i++
		if m.AdminStateUp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.FixedIps) > 0 {
		for _, msg := range m.FixedIps {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	if len(m.DeviceOwner) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.DeviceOwner)))
		i += copy(dAtA[i:], m.DeviceOwner)
	}
	if len(m.SecurityGroups) > 0 {
		for _, s := range m.SecurityGroups {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DeviceId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.DeviceId)))
		i += copy(dAtA[i:], m.DeviceId)
	}
	if len(m.AllowedAddressPairs) > 0 {
		for _, msg := range m.AllowedAddressPairs {
			dAtA[i] = 0x62
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HostRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestinationCidr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.DestinationCidr)))
		i += copy(dAtA[i:], m.DestinationCidr)
	}
	if len(m.NextHop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NextHop)))
		i += copy(dAtA[i:], m.NextHop)
	}
	return i, nil
}

func (m *AllocationPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocationPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *Subnet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subnet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.NetworkId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.NetworkId)))
		i += copy(dAtA[i:], m.NetworkId)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IpVersion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(m.IpVersion))
	}
	if len(m.Cidr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.Cidr)))
		i += copy(dAtA[i:], m.Cidr)
	}
	if len(m.GatewayIp) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.GatewayIp)))
		i += copy(dAtA[i:], m.GatewayIp)
	}
	if len(m.DnsNameServers) > 0 {
		for _, s := range m.DnsNameServers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AllocationPools) > 0 {
		for _, msg := range m.AllocationPools {
			dAtA[i] = 0x42
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.HostRoutes) > 0 {
		for _, msg := range m.HostRoutes {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintNeutron(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EnableDhcp {
		dAtA[i] = 0x50
		i++
		if m.EnableDhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TenantId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintNeutron(dAtA, i, uint64(len(m.TenantId)))
		i += copy(dAtA[i:], m.TenantId)
	}
	return i, nil
}

func encodeFixed64Neutron(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Neutron(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNeutron(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FloatingIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.FloatingNetworkId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.FloatingIpAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.FixedIpAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.RouterId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *NetworkExternal) Size() (n int) {
	var l int
	_ = l
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.External {
		n += 2
	}
	return n
}

func (m *GatewayInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	l = len(m.NextHop)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.DestinationCidr)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.GatewayInfo != nil {
		l = m.GatewayInfo.Size()
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.AdminStateUp {
		n += 2
	}
	if m.Distributed {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	return n
}

func (m *InterfaceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *PortBinding) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.HostId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.VifDetails) > 0 {
		for k, v := range m.VifDetails {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovNeutron(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovNeutron(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovNeutron(uint64(mapEntrySize))
		}
	}
	l = len(m.VifType)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.VnicType)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.Profile) > 0 {
		for k, v := range m.Profile {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovNeutron(uint64(len(k))) + 1 + len(v) + sovNeutron(uint64(len(v)))
			n += mapEntrySize + 1 + sovNeutron(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NetworkExtAttrs) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.AdminStateUp {
		n += 2
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.Shared {
		n += 2
	}
	l = len(m.NetworkType)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.PhysicalNetwork)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.SegmentationId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.Segments) > 0 {
		for _, e := range m.Segments {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	return n
}

func (m *NetworkExtAttrs_Segment) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhysicalNetwork)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.NetworkType)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.SegmentationId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *SecGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.SecurityGroupRules) > 0 {
		for _, e := range m.SecurityGroupRules {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *SecGroupRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Ethertype)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.SecurityGroupId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.PortRangeMin != 0 {
		n += 1 + sovNeutron(uint64(m.PortRangeMin))
	}
	if m.PortRangeMax != 0 {
		n += 1 + sovNeutron(uint64(m.PortRangeMax))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.RemoteGroupId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.RemoteIpPrefix)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *Network) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.AdminStateUp {
		n += 2
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.Shared {
		n += 2
	}
	return n
}

func (m *IP) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *AddressPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *Port) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.AdminStateUp {
		n += 2
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.FixedIps) > 0 {
		for _, e := range m.FixedIps {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.DeviceOwner)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.SecurityGroups) > 0 {
		for _, s := range m.SecurityGroups {
			l = len(s)
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.AllowedAddressPairs) > 0 {
		for _, e := range m.AllowedAddressPairs {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	return n
}

func (m *HostRoute) Size() (n int) {
	var l int
	_ = l
	l = len(m.DestinationCidr)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.NextHop)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *AllocationPool) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func (m *Subnet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if m.IpVersion != 0 {
		n += 1 + sovNeutron(uint64(m.IpVersion))
	}
	l = len(m.Cidr)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	l = len(m.GatewayIp)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	if len(m.DnsNameServers) > 0 {
		for _, s := range m.DnsNameServers {
			l = len(s)
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	if len(m.AllocationPools) > 0 {
		for _, e := range m.AllocationPools {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	if len(m.HostRoutes) > 0 {
		for _, e := range m.HostRoutes {
			l = e.Size()
			n += 1 + l + sovNeutron(uint64(l))
		}
	}
	if m.EnableDhcp {
		n += 2
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovNeutron(uint64(l))
	}
	return n
}

func sovNeutron(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNeutron(x uint64) (n int) {
	return sovNeutron(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FloatingIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatingIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatingIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingNetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingNetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatingIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FloatingIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkExternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkExternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkExternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.External = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayInfo == nil {
				m.GatewayInfo = &GatewayInfo{}
			}
			if err := m.GatewayInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStateUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminStateUp = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distributed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Distributed = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &Port{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNeutron
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.VifDetails == nil {
				m.VifDetails = make(map[string][]byte)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNeutron
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapbyteLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNeutron
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapbyteLen |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intMapbyteLen := int(mapbyteLen)
				if intMapbyteLen < 0 {
					return ErrInvalidLengthNeutron
				}
				postbytesIndex := iNdEx + intMapbyteLen
				if postbytesIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := make([]byte, mapbyteLen)
				copy(mapvalue, dAtA[iNdEx:postbytesIndex])
				iNdEx = postbytesIndex
				m.VifDetails[mapkey] = mapvalue
			} else {
				var mapvalue []byte
				m.VifDetails[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnicType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnicType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthNeutron
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Profile == nil {
				m.Profile = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNeutron
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNeutron
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthNeutron
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Profile[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Profile[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkExtAttrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkExtAttrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkExtAttrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStateUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminStateUp = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &Subnet{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shared = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segments = append(m.Segments, &NetworkExtAttrs_Segment{})
			if err := m.Segments[len(m.Segments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkExtAttrs_Segment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Segment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Segment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalNetwork", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalNetwork = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegmentationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroupRules = append(m.SecurityGroupRules, &SecGroupRule{})
			if err := m.SecurityGroupRules[len(m.SecurityGroupRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecGroupRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecGroupRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecGroupRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethertype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ethertype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRangeMin", wireType)
			}
			m.PortRangeMin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRangeMin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRangeMax", wireType)
			}
			m.PortRangeMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortRangeMax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteGroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteGroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStateUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminStateUp = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &Subnet{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shared = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Port) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Port: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Port: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminStateUp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminStateUp = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedIps = append(m.FixedIps, &IP{})
			if err := m.FixedIps[len(m.FixedIps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecurityGroups = append(m.SecurityGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAddressPairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedAddressPairs = append(m.AllowedAddressPairs, &AddressPair{})
			if err := m.AllowedAddressPairs[len(m.AllowedAddressPairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocationPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocationPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocationPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsNameServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsNameServers = append(m.DnsNameServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationPools = append(m.AllocationPools, &AllocationPool{})
			if err := m.AllocationPools[len(m.AllocationPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostRoutes = append(m.HostRoutes, &HostRoute{})
			if err := m.HostRoutes[len(m.HostRoutes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDhcp = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNeutron
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNeutron(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNeutron
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNeutron(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNeutron
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNeutron
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNeutron
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNeutron
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNeutron(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNeutron = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNeutron   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("openstack/neutron/neutron.proto", fileDescriptorNeutron) }

var fileDescriptorNeutron = []byte{
	// 1425 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0xdd, 0x6e, 0xdc, 0x44,
	0x14, 0x66, 0x7f, 0xb2, 0xeb, 0x3d, 0xde, 0x26, 0xe9, 0xb4, 0xc0, 0x92, 0xb6, 0x69, 0xea, 0x42,
	0x49, 0x11, 0x5a, 0x44, 0x10, 0xa2, 0x14, 0x21, 0xd1, 0xd2, 0xd2, 0x5a, 0x22, 0x65, 0x71, 0xa0,
	0x02, 0x6e, 0xac, 0x89, 0x67, 0x36, 0x3b, 0xd4, 0x3b, 0x63, 0x8d, 0x67, 0xf3, 0x73, 0xc7, 0x2b,
	0x70, 0xc7, 0x25, 0x0f, 0x00, 0x57, 0xbc, 0x02, 0x12, 0x5c, 0xf2, 0x00, 0x20, 0xa1, 0xf2, 0x22,
	0x68, 0x7e, 0xbc, 0xb1, 0x9d, 0x64, 0xdb, 0x0b, 0xae, 0xb8, 0x8a, 0xe7, 0xf3, 0x39, 0xdf, 0x9e,
	0x9f, 0x6f, 0x8e, 0x4f, 0xe0, 0xaa, 0xc8, 0x28, 0xcf, 0x15, 0x4e, 0x9e, 0xbc, 0xc5, 0xe9, 0x4c,
	0x49, 0xc1, 0x8b, 0xbf, 0xc3, 0x4c, 0x0a, 0x25, 0xd0, 0x80, 0x26, 0x13, 0x91, 0xed, 0x0e, 0xe7,
	0x76, 0x43, 0xf7, 0x3e, 0xf8, 0xbe, 0x09, 0xf0, 0x49, 0x2a, 0xb0, 0x62, 0x7c, 0x2f, 0x1c, 0xa1,
	0x65, 0x68, 0x32, 0x32, 0x68, 0x6c, 0x34, 0x36, 0x7b, 0x51, 0x93, 0x11, 0x34, 0x84, 0x0b, 0x63,
	0xf7, 0x36, 0xe6, 0x54, 0x1d, 0x08, 0xf9, 0x24, 0x66, 0x64, 0xd0, 0x34, 0x06, 0xe7, 0x8b, 0x57,
	0x8f, 0xec, 0x9b, 0xb0, 0x6a, 0xcf, 0xb2, 0x18, 0x13, 0x22, 0x69, 0x9e, 0x0f, 0x5a, 0x55, 0xfb,
	0x30, 0xbb, 0x63, 0x5f, 0xa0, 0x97, 0xa1, 0x9b, 0x09, 0xa9, 0x34, 0x67, 0xdb, 0xd8, 0x74, 0xf4,
	0x31, 0x24, 0x68, 0x13, 0x56, 0xc7, 0xec, 0x90, 0x92, 0x32, 0xcb, 0x92, 0xb1, 0x58, 0x36, 0xf8,
	0x31, 0xc5, 0x25, 0xe8, 0x29, 0xca, 0x31, 0x37, 0x24, 0x1d, 0x63, 0xe2, 0x59, 0x20, 0x24, 0xe8,
	0x25, 0xe8, 0xe4, 0x0a, 0xab, 0x59, 0x3e, 0xe8, 0x5a, 0x7a, 0x7b, 0xd2, 0x4e, 0x52, 0xcc, 0x14,
	0x95, 0xda, 0xc9, 0xb3, 0x4e, 0x16, 0x08, 0x49, 0xf0, 0x2d, 0xac, 0xb8, 0x8c, 0xee, 0x1f, 0x2a,
	0x2a, 0x39, 0x4e, 0xd1, 0x07, 0xd0, 0x75, 0xe9, 0x9b, 0xe2, 0xf8, 0x5b, 0xd7, 0x86, 0x67, 0x95,
	0x74, 0xe8, 0x7c, 0xa3, 0xc2, 0x03, 0xad, 0x81, 0x47, 0x1d, 0x91, 0xa9, 0x9c, 0x17, 0xcd, 0xcf,
	0xc1, 0x9b, 0xe0, 0x3f, 0xc0, 0x8a, 0x1e, 0xe0, 0xa3, 0x90, 0x8f, 0x05, 0xba, 0x02, 0x50, 0x2a,
	0xb3, 0xed, 0x43, 0x8f, 0x17, 0xe5, 0x0d, 0xb6, 0x61, 0x29, 0xd2, 0x51, 0xa2, 0x57, 0xc0, 0xe3,
	0xf4, 0x50, 0xc5, 0x13, 0x91, 0x39, 0xab, 0xae, 0x3e, 0x3f, 0x14, 0x19, 0xba, 0x09, 0xab, 0x84,
	0xe6, 0x8a, 0x71, 0xac, 0x98, 0xe0, 0x71, 0xc2, 0x88, 0x74, 0xfd, 0x5a, 0x29, 0xe1, 0x1f, 0x33,
	0x22, 0x83, 0x9f, 0x9a, 0xd0, 0x31, 0x7c, 0xb2, 0x54, 0xa8, 0x46, 0xa5, 0x50, 0x0f, 0xa1, 0xbf,
	0x67, 0xe3, 0x8b, 0x19, 0x1f, 0x0b, 0xc3, 0xe4, 0x6f, 0xbd, 0x76, 0x76, 0xf6, 0xa5, 0x6c, 0x22,
	0x7f, 0xaf, 0x94, 0xda, 0xab, 0xb0, 0x8c, 0xc9, 0x94, 0xf1, 0x58, 0x33, 0xd3, 0x78, 0x96, 0x19,
	0x55, 0x78, 0x51, 0xdf, 0xa0, 0x3b, 0x1a, 0xfc, 0x32, 0x43, 0x1b, 0xe0, 0x13, 0x96, 0x2b, 0xc9,
	0x76, 0x67, 0x8a, 0x5a, 0x51, 0x78, 0x51, 0x19, 0x42, 0x08, 0xda, 0x1c, 0x4f, 0xa9, 0x53, 0x83,
	0x79, 0x76, 0xb2, 0xed, 0xcc, 0x65, 0x5b, 0xd1, 0x44, 0xb7, 0xa6, 0x89, 0xf7, 0xa0, 0x63, 0x5a,
	0x9d, 0x0f, 0xbc, 0x8d, 0xd6, 0xa6, 0xbf, 0x75, 0xf5, 0xec, 0x64, 0x4c, 0x71, 0x22, 0x67, 0x1e,
	0x48, 0x38, 0x17, 0x72, 0x45, 0xe5, 0x18, 0x27, 0xd4, 0xa4, 0x74, 0x09, 0x7a, 0xf9, 0x6c, 0x97,
	0x53, 0x75, 0xdc, 0x2c, 0xcf, 0x02, 0x21, 0x29, 0x4b, 0xbb, 0x59, 0x91, 0xb6, 0x0d, 0xb6, 0x75,
	0x7a, 0xb0, 0xed, 0x6a, 0xb0, 0xc1, 0x2f, 0x2d, 0xf0, 0x47, 0x42, 0xaa, 0xbb, 0x8c, 0x13, 0xc6,
	0xf7, 0xd0, 0x16, 0xb4, 0x35, 0x8d, 0x53, 0xe1, 0xfa, 0xd9, 0xa1, 0x6b, 0xa7, 0xc8, 0xd8, 0xea,
	0x48, 0x26, 0x22, 0x2f, 0x47, 0xa2, 0x8f, 0x21, 0x41, 0x8f, 0xc1, 0xdf, 0x67, 0xe3, 0x98, 0x50,
	0x85, 0x59, 0xaa, 0x6f, 0xa9, 0x2e, 0xc7, 0xbb, 0x8b, 0x39, 0x5d, 0x20, 0xc3, 0xc7, 0x6c, 0x7c,
	0xcf, 0xfa, 0xdd, 0xe7, 0x4a, 0x1e, 0x45, 0xb0, 0x3f, 0x07, 0xb4, 0x3a, 0x35, 0xaf, 0x3a, 0xca,
	0xa8, 0x4b, 0xa8, 0xbb, 0xcf, 0xc6, 0x5f, 0x1c, 0x65, 0x54, 0x27, 0xbb, 0xcf, 0x59, 0x62, 0xdf,
	0xd9, 0x16, 0x7a, 0x1a, 0x30, 0x2f, 0x3f, 0x85, 0x6e, 0x26, 0xc5, 0x98, 0xa5, 0x74, 0xd0, 0x31,
	0xb1, 0x6c, 0x3d, 0x5f, 0x2c, 0x23, 0xeb, 0x64, 0x03, 0x29, 0x28, 0xd6, 0x3e, 0x84, 0x95, 0x5a,
	0x90, 0x68, 0x15, 0x5a, 0x4f, 0xe8, 0x91, 0x6b, 0x95, 0x7e, 0x44, 0x17, 0x61, 0x69, 0x1f, 0xa7,
	0x33, 0x6a, 0x2a, 0xd3, 0x8f, 0xec, 0xe1, 0x76, 0xf3, 0x56, 0x63, 0xed, 0x36, 0xf4, 0xcb, 0xbc,
	0xcf, 0xf2, 0xed, 0x95, 0x7c, 0x83, 0x9f, 0xdb, 0xe5, 0x11, 0x72, 0x47, 0x29, 0x99, 0x9f, 0x18,
	0xad, 0x85, 0x8e, 0x9b, 0x25, 0x1d, 0x3f, 0xdf, 0x1d, 0x39, 0xbe, 0xab, 0xed, 0xca, 0x5d, 0xbd,
	0x0d, 0x5d, 0xab, 0x3e, 0x3d, 0x2a, 0x75, 0xf9, 0x36, 0xce, 0x2e, 0xdf, 0x8e, 0x31, 0x8c, 0x0a,
	0x87, 0x67, 0x4f, 0xd1, 0x09, 0x96, 0xd4, 0xde, 0x25, 0x2f, 0x72, 0x27, 0x74, 0x0d, 0xfa, 0xc5,
	0xb4, 0x32, 0xfd, 0xb4, 0x83, 0xd4, 0x77, 0x98, 0x69, 0xe9, 0x4d, 0x58, 0xcd, 0x26, 0x47, 0x39,
	0x4b, 0x70, 0x5a, 0x7c, 0x40, 0x06, 0x3d, 0x3b, 0x8d, 0x0a, 0xdc, 0x15, 0x0a, 0xbd, 0x0e, 0x2b,
	0x39, 0xdd, 0x9b, 0x52, 0xae, 0xec, 0xe4, 0x62, 0x64, 0x00, 0x76, 0xe2, 0x97, 0xe1, 0x90, 0xa0,
	0x6d, 0xf0, 0x1c, 0x92, 0x0f, 0x7c, 0x93, 0xe8, 0xdb, 0xcf, 0x9c, 0xc6, 0x45, 0x1b, 0x86, 0x3b,
	0xd6, 0x33, 0x9a, 0x53, 0xac, 0x7d, 0xd7, 0x80, 0xae, 0x43, 0x4f, 0x0d, 0xb7, 0x71, 0x7a, 0xb8,
	0xf5, 0xe4, 0x9b, 0x27, 0x93, 0x3f, 0x25, 0xa3, 0xd6, 0x69, 0x19, 0x05, 0xbf, 0x35, 0xc0, 0xdb,
	0xa1, 0xc9, 0x03, 0x29, 0x66, 0xd9, 0x73, 0x09, 0x45, 0x8f, 0x49, 0x9a, 0x27, 0x92, 0x65, 0x9a,
	0xc1, 0xb1, 0x96, 0x21, 0xf4, 0x15, 0x5c, 0xcc, 0x69, 0x32, 0x93, 0x4c, 0x1d, 0xc5, 0x7b, 0x9a,
	0x37, 0x96, 0xb3, 0x94, 0x6a, 0xc9, 0xe8, 0x82, 0xdd, 0x58, 0xa0, 0x0c, 0x17, 0x47, 0x34, 0x4b,
	0x69, 0x84, 0x0a, 0x8e, 0x39, 0x54, 0x93, 0xca, 0x52, 0x6d, 0x5e, 0xfd, 0xd5, 0x84, 0x7e, 0x99,
	0xe1, 0x44, 0x36, 0x97, 0xa1, 0x47, 0x98, 0xa4, 0x89, 0x89, 0xdb, 0xa6, 0x74, 0x0c, 0xe8, 0xb7,
	0x54, 0x4d, 0xa8, 0x34, 0x15, 0xb5, 0x59, 0x1d, 0x03, 0xe8, 0x0d, 0x38, 0x5f, 0xcb, 0x69, 0x3e,
	0x31, 0x57, 0x2a, 0x81, 0x86, 0x44, 0x5f, 0x25, 0x33, 0x7e, 0x25, 0xe6, 0x7b, 0x34, 0x9e, 0x32,
	0x6e, 0x42, 0x5d, 0x8a, 0xfa, 0x1a, 0x8d, 0x34, 0xb8, 0xcd, 0x78, 0xdd, 0x0a, 0x1f, 0x1a, 0xed,
	0x57, 0xac, 0xf0, 0xa1, 0xfe, 0x80, 0x9b, 0x3d, 0x2a, 0x11, 0x69, 0xf1, 0x35, 0x29, 0xce, 0xe8,
	0x06, 0xac, 0x48, 0x3a, 0x15, 0x8a, 0x1e, 0x47, 0x64, 0xaf, 0xc1, 0x39, 0x0b, 0x17, 0xf1, 0x6c,
	0xc2, 0xaa, 0xb3, 0x63, 0x59, 0x9c, 0x49, 0x3a, 0x66, 0x87, 0xee, 0x22, 0x2c, 0x5b, 0x3c, 0xcc,
	0x46, 0x06, 0xad, 0xd6, 0x17, 0x6a, 0xf5, 0xfd, 0xb3, 0x01, 0xdd, 0x42, 0x81, 0xff, 0xbf, 0x89,
	0x12, 0x7c, 0x04, 0xcd, 0x70, 0xb4, 0xf8, 0xbb, 0x7a, 0x05, 0xa0, 0xb4, 0x13, 0x3a, 0x05, 0xb1,
	0x62, 0x1d, 0x0c, 0xb6, 0xc1, 0x77, 0x8f, 0x23, 0xcc, 0x64, 0xcd, 0xba, 0x51, 0xb3, 0x46, 0x57,
	0xc1, 0x9f, 0xe2, 0xa4, 0xc6, 0x06, 0x53, 0x9c, 0x14, 0x74, 0xbf, 0xb6, 0xa0, 0xad, 0x3f, 0x35,
	0x27, 0x8a, 0x5d, 0xdd, 0xd4, 0x9a, 0xb5, 0x4d, 0x6d, 0xde, 0x8b, 0xd6, 0xc2, 0x5e, 0xb4, 0x17,
	0xf6, 0x62, 0xa9, 0xd2, 0x8b, 0x5a, 0xa8, 0x9d, 0x7a, 0xa8, 0xe8, 0x7d, 0xe8, 0x15, 0x2b, 0xb3,
	0x5e, 0x77, 0x75, 0xbb, 0x2e, 0x9f, 0xdd, 0xae, 0x70, 0x14, 0x79, 0x6e, 0x93, 0xae, 0xf5, 0xca,
	0xab, 0xf5, 0xea, 0x1a, 0xf4, 0x09, 0xdd, 0x67, 0x09, 0x8d, 0xc5, 0x01, 0xa7, 0xd2, 0xa9, 0xd6,
	0xb7, 0xd8, 0x67, 0x1a, 0xb2, 0x83, 0xae, 0x7c, 0x31, 0xf3, 0x01, 0x6c, 0xb4, 0xec, 0xa0, 0x2b,
	0x5d, 0x4b, 0xf3, 0x43, 0x8e, 0x8b, 0x91, 0x81, 0x6f, 0x7f, 0xc8, 0x02, 0x21, 0x41, 0x5f, 0xc3,
	0x8b, 0x38, 0x4d, 0xc5, 0x01, 0x25, 0x45, 0x96, 0x71, 0x86, 0x99, 0xcc, 0x07, 0x7d, 0x93, 0xcc,
	0x82, 0xa5, 0xb3, 0xd4, 0xf1, 0xe8, 0x82, 0xe3, 0x28, 0x61, 0x79, 0xf0, 0x39, 0xf4, 0x1e, 0x8a,
	0x5c, 0xd9, 0xe5, 0xf9, 0xb4, 0x0d, 0xb9, 0x71, 0xea, 0x86, 0x5c, 0xd9, 0xb3, 0x9b, 0x95, 0x3d,
	0x3b, 0xb8, 0x05, 0xcb, 0x77, 0xd2, 0x54, 0x24, 0xc6, 0x78, 0x24, 0x44, 0xaa, 0xf7, 0x81, 0x5c,
	0x61, 0xb7, 0x9c, 0xf5, 0x22, 0x7b, 0xd0, 0x7b, 0x03, 0xe5, 0x85, 0x42, 0xf4, 0x63, 0xf0, 0x63,
	0x0b, 0x3a, 0xf6, 0xb6, 0xfc, 0x17, 0xaa, 0xb2, 0x0a, 0xdf, 0xa7, 0x32, 0xd7, 0x13, 0xb5, 0x6d,
	0xc6, 0x57, 0x8f, 0x65, 0x8f, 0x2d, 0xa0, 0x5d, 0x4c, 0x82, 0x6e, 0x5d, 0xd6, 0xcf, 0xda, 0x65,
	0xbe, 0xd4, 0x67, 0x4e, 0x49, 0xbd, 0x62, 0x57, 0xcf, 0xf4, 0xa8, 0x22, 0x3c, 0x8f, 0x35, 0x7b,
	0x9c, 0x53, 0xa9, 0xa9, 0x8d, 0x9e, 0x7a, 0xd1, 0x32, 0xe1, 0xf9, 0x23, 0x3c, 0xa5, 0x3b, 0x16,
	0x45, 0x3b, 0xb0, 0x8a, 0xe7, 0x35, 0x88, 0x33, 0x21, 0xd2, 0x62, 0xa9, 0xde, 0x5c, 0xd0, 0xac,
	0x4a, 0xd5, 0xa2, 0x15, 0x5c, 0x39, 0xe7, 0xe8, 0x1e, 0xf8, 0x66, 0x5d, 0x75, 0x4b, 0x7a, 0xcf,
	0xf0, 0x5d, 0x3f, 0x9b, 0x6f, 0xde, 0xd8, 0x08, 0x26, 0xc5, 0xa3, 0xb9, 0x2e, 0x94, 0xe3, 0xdd,
	0x94, 0xc6, 0x64, 0x92, 0x64, 0x66, 0x8e, 0x7a, 0x11, 0x58, 0xe8, 0xde, 0x24, 0xc9, 0xaa, 0x9a,
	0xf7, 0xab, 0x9a, 0xbf, 0x7b, 0xfd, 0xf7, 0xa7, 0xeb, 0x8d, 0x3f, 0x9e, 0xae, 0x37, 0xfe, 0x7e,
	0xba, 0xde, 0xf8, 0xe1, 0x9f, 0xf5, 0x17, 0xbe, 0x39, 0x7f, 0xe2, 0x7f, 0xec, 0xdd, 0x8e, 0xf9,
	0x08, 0xbc, 0xf3, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70, 0x18, 0xbc, 0x59, 0x7f, 0x0f, 0x00,
	0x00,
}
